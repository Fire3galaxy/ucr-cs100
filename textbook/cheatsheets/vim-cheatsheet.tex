\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage[margin=.6in]{geometry}
\usepackage{longtable}
\usepackage{listings}
\usepackage{multicol}
\usepackage{color}

\lstset{ %
basicstyle=\large % For font size
}
\newcommand{\lstcode}[1]{
\begin{lstlisting} 
#1
\end{lstlisting} }

\title{CS100 Syscall Cheatsheet}
\author{}
\date{}

\begin{document}
\maketitle

\large This document contains interfaces, libraries, descriptions, and errors for 
syscalls used in CS100. I list errors on the back. For your linux's safety and 
your grade's safety, please use perror() with every syscall.

\begin{tabular}{l|l}
\begin{lstlisting} 
void perror(const char* s) 
\end{lstlisting} 
&
\begin{lstlisting} 
stdio.h, errno.h 
\end{lstlisting}
\\
& prints argument message \begin{lstlisting} 
s 
\end{lstlisting}
\ based on global int 
    \begin{lstlisting}
errno
    \end{lstlisting}
\end{tabular}


\medskip
\begin{tabular}{llll}
    \bf Function & \bf Interface & \bf Include & \bf Description\\
    perror() & void perror(const char* s) &  stdio.h &  prints error message\\
    && errno.h & based on global int \it errno \rm
\end{tabular}
\normalsize

\section{Syscall interface and libraries}
\begin{longtable}{llll}
    \bf Function & \bf Interface & \bf Include & \bf Description
    \\
    fork() & pid\_t fork(void) & unistd.h & creates child process.
    \\
%----------------------------Fork()
    & & & %Returns 0 to child process and child's pid to parent process,
    \\
    & & & %or -1 if error. No child made if error.
    \\ \hline
    execv() & int execv(const char* path, & unistd.h & executes programs and 
        passes arguments, 
    \\
    &  \ \ \ \ \ \ \ \ \ \ \ char *const argv\textbf{[]}) & &requires full path name of program
%-----------------------------Exec note!!!!!!
    %& & & if exec succeeds, the current process will end and exec will not return. It returns -1 if it fails (e.g. program file not found)
    \\ \hline
    execvp() & int execvp(const char* file, & unistd.h & executes programs and 
        passes arguments, 
    \\
    &  \ \ \ \ \ \ \ \ \ \ \ char *const argv\textbf{[]}) & &finds program file automatically
    \\ \hline
    wait() & pid\_t wait(int* status) & sys/types.h & waits for child process to terminate
    \\
%-----------------------------Wait
    & & sys/wait.h & %returns pid if succeeds, -1 if fails (e.g. invalid pid)
    \\
    & & & %int* status stores exit status of child process. Use NULL if not needed.
    \\ \hline
    waitpid() & pid\_t waitpid(pid\_t pid, & sys/types.h & similar to wait(), can specify pid,
    \\
    & \ \ \ \ \ \ \ \ \ \ int* status, int options) & sys/wait.h & can also wait for stopped processes
%   \\
%---------------------------------WAITPID
%    & & & Can add option to wait for process to stop (WUNTRACED) or to just check process (WNOHANG)
%returns pid if succeeds, -1 if fails (e.g. invalid pid)
    \\ \hline
    opendir() & DIR* opendir(const char* name) & sys/types.h & opens directory stream and returns
    \\
    & & dirent.h & pointer to its first entry
%----------------------------------OPENDIR
% Returns NULL on failure
    \\ \hline
    readdir() & struct dirent* readdir(DIR* dirp) & dirent.h & means "read directory",
    \\
    & & & returns pointer to struct dirent of next 
    \\
    & & & item in directory or null (end of dir/error)
    \\ \hline
    closedir() & int closedir(DIR* dirp) & sys/types.h & closes  directory
    \\
%---------------------------------CLOSEDIR
    & & dirent.h & %returns 0 on success, -1 on failure
    \\  \hline
    chdir() & int chdir(const char* path) & unistd.h & change directory of calling process
    \\
    & & & to \it path \rm
%----------------------------------CHDIR
%returns 0 on success, -1 on failure
    \\ \hline
    open() & int open(const char* pathname, int flags) & sys/types.h & opens file and returns file descriptor
    \\
    & int open(const char* pathname, int flags, & sys/stat.h & which can be used, with flags,
    \\
    & \ \ \ \ \ \ \ \ \ \ mod\_t mode) & fcntl.h & to read/write/create file
%------------------------------------OPEN
%Flags: Must use either O_RDONLY (read file), O_WRONLY (write to file), or O_RDWR (both) in call
%\t These can be bitwise OR'd ('|') with other flags. O_CREAT creates file if it doesn't exist
%\t O_TRUNC overwrites contents of file, O_APPEND writes at the end of file
%\t When creating files, `mode` arguments can be added to specify permissions of new file
    \\ \hline
    close() & int close(int fd) & unistd.h & close a file descriptor
%-------------------------------------CLOSE
%returns 0 on success, -1 on failure
    \\ \hline
    stat() & int stat(const char* path, & sys/types.h & gives information about a file in struct stat,
    \\
    & \ \ \ \ \ \ \ \ \ \ struct stat* buf) & sys/stat.h & e.g. permissions, type of file, time created,
    \\
    & & unistd.h & see \it ls -l \rm
%-------------------------------------STAT
%has macros that take st_mode and returns true/false e.g. S_ISDIR(st_mode)
%returns 0 on success, -1 on failure
    \\ \hline
    dup() & int dup(int oldfd) & unistd.h & creates copy of file descriptor in lowest 
    \\ 
    & & &unused descriptor 

    \\ \hline
    dup2() & int dup2(int oldfd, int newfd) & unistd.h & creates copy of oldfd in newfd, 
    \\
    & & &closes newfd if it exists already 
    \\ \pagebreak
    \bf Function & \bf Interface & \bf Include & \bf Description
    \\ \hline
    pipe() & int pipe(int pipefd\textbf{[}2\textbf{]}) & unistd.h & gives two file descriptors through pipefd,
    \\
    & & & pipefd\textbf{[}0\textbf{]} $\rightarrow$ read
    \\
    & & & pipefd\textbf{[}1\textbf{]} $\rightarrow$ write
    \\ \hline
    kill() & int kill(pid\_t pid, int sig) & sys/types.h & sends any signal to process
    \\
    & & signal.h & or proccess group
    \\ \hline
    getcwd() & char* getcwd(char*buf, size\_t size)& unistd.h & get current working directory,
    \\
    & & & copy to buf if present
    \\ \hline
    getenv() & char* getenv(const char* name) & stdlib.h & returns value of environmental variable
    \\ \hline
    getgrgid() & struct group* getgrgid(gid\_t gid) & sys/types.h & get struct with group info,
    \\
    & &grp.h  &requires group id
    \\ \hline
    gethostname() & int gethostname(char* name, size\_t len) & unistd.h & write hostname in char array \it name\rm, 
    \\
    & & & size \it len\rm
    \\ \hline
    getlogin() & char* getlogin(void) & stdio.h & get char pointer to logged in username
    \\ \hline
    getpwuid & struct passwd* getpwuid(uid\_t uid) & sys/types.h & get struct with user info,
    \\
    & & pwd.h &requires user id \it uid \rm
    \\ \hline
    ioctl() & int ioctl(int d, int request, ...) & sys/ioctl.h & send request to file descriptor d,
    \\
    & & & used to manipulate devices and terminals
    
    
    
    
\end{longtable}

\section{Common syscall errors}
\large \rm

\end{document}
