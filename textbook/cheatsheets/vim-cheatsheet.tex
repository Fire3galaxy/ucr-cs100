\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage[margin=.6in]{geometry}
\usepackage{longtable}
\usepackage{listings}
\usepackage{multicol}
\usepackage{multirow}
\usepackage{color}
\usepackage{tabu}
\usepackage{microtype}

%\makeatletter % To make function descriptions indent when they're long
%\newcommand*\indenth[2]{%
%  \@hangfrom{#1}%
%  {#2}%
%} 
%\makeatother

%Indent w/ static #
\newcommand{\indenth}[1][.5]{\hangindent=#1in
                         \hangafter=1 }

\lstset{ %
basicstyle=\large % For font size
}

\title{CS100 Syscall Cheatsheet}
\author{Read your man pages, and sleep once in a while, k?}
\date{}

\begin{document}
\maketitle

\large This document contains interfaces, libraries, descriptions, and errors for 
syscalls used in CS100. They're organized by category and order of use in the class (as of Winter 2015). For your linux's safety and 
your grade's safety, please use \texttt{perror()} with every syscall. 

\medskip
\begin{tabu} {p{1in}|p{5.7in}}
\texttt{perror()} & \indenth\texttt{void perror(const char* s)} --- prints \texttt{s} and syscall's error message as defined by global int \texttt{errno} to \texttt{stderr}
    \\
& \texttt{stdio.h}, \texttt{errno.h}
\end{tabu}
\normalsize

\section{Syscall interface and libraries}
\begin{longtabu}{p{1in}|p{5.7in}}
    \bf Function & \textbf{Interface, Include, Description}
        \\ \hline
    % fork
    \texttt{fork()} &  \indenth\texttt{pid\_t fork(void)} --- Creates child process. Returns 0 to child process and child's pid to parent process, or -1 if error. No child process made if error occurs.
        \\
    & \texttt{unistd.h}
    %
    % exec
        \\ \hline
    \texttt{exec} & \indenth\texttt{Exec} note: If \texttt{exec} succeeds, the current process will end and \texttt{exec} will not return. It returns \texttt{-1} if it fails (e.g. program file not found). \texttt{char *const argv} also must be \texttt{NULL} terminated. \par
        \\
    \texttt{execv()} & \indenth\texttt{int execv(const char* path, char *const argv[])} --- Executes program \texttt path and passes arguments \texttt{argv}. Requires full path name of program.
        \\
    & \texttt{unistd.h}
        \\
    \texttt{execvp()} & \indenth\texttt{int execvp(const char* file, char *const argv[])} Executes program \texttt path and passes arguments \texttt{argv}., finds program file automatically by checking directories in environmental variable \texttt{PATH}
        \\
    & \texttt{unistd.h}
    %
    % wait
        \\ \hline
    \texttt{wait()} & \indenth\texttt{pid\_t wait(int* status)} --- Waits for child process to terminate. Returns \texttt{pid} if succeeds, \texttt -1 if fails (e.g. no child). \texttt{int* status} stores exit status of child process. Use \texttt NULL if not needed. 
        \\
    & \texttt sys/wait.h
    %
        \\ \hline
    \texttt{waitpid()} & \indenth\texttt{pid\_t waitpid(pid\_t pid, int* status, int options)} --- Similar to \texttt wait(). Can specify \texttt pid to wait for specific child; use 0 to wait for any child. Can also wait for stopped processes by adding option \texttt WUNTRACED and check immediately instead of waiting with \texttt WNOHANG (Bitwise OR '\texttt{|}' to combine options). Returns \texttt pid if succeeds, \texttt -1 if fails (e.g. invalid pid).
        \\
    & \texttt sys/wait.h
    % opendir
        \\ \hline
    Directories and Files & \indenth Note: When these functions require a directory or file name, they only require a \itshape relative path\rm. This means that if your process was called in directory \texttt{bin/foo/bar/}, instead of using \texttt{bin/foo/bar/p.cpp}, the \itshape absolute path\rm, as your parameter, you can use \texttt{p.cpp} or \texttt{./p.cpp} instead. \par
        \\
    \texttt{opendir()} & \indenth\texttt{DIR* opendir(const char* name)} --- opens directory stream to directory \texttt{name} and returns pointer to its first entry. Returns NULL on error. 
        \\
    & \texttt dirent.h
        %
        \\ \hline
    \texttt{closedir()} & \indenth\texttt{int closedir(DIR* dirp)} --- Closes  directory. returns 0 on success, -1 on failure
        \\
    & \texttt dirent.h
        %
        \\ \hline
    \texttt{chdir()} & \indenth\texttt{int chdir(const char* path)} --- change directory of calling process to \it path \rm . Returns 0 on success, -1 on failure.
        \\
    & \texttt
        %
        \\ \hline
    \texttt{stat()} & \indenth\texttt{int stat(const char* path,  struct stat* buf)} --- Gives information about a file in \texttt{struct stat}, e.g. permissions, type of file, time created. See \texttt{ls -l} for example of provided information. Macros are also provided that take \texttt{mode_t st_mode} in \texttt{struct stat} and returns true/false e.g. \texttt{S_ISDIR(st_mode)}, \texttt{S_REG(st_mode)}. Returns \texttt 0 on success, \texttt -1 on failure.
        \\
    & \texttt{sys/types.h}, \texttt{sys/stat.h}, \texttt{unistd.h}
        %
        \\ \hline
    \texttt{open()} & \texttt{int open(const char* pathname, int flags)}
        \\
    & \texttt{int open(const char* pathname, int flags, mod\_t mode)}
        \\
    & \indenth Opens file and returns file descriptor which can be used, with flags, to read/write/create file. Flags: Must use either \texttt O\_RDONLY (read file), \texttt O_WRONLY (write to file), or \texttt O_RDWR (both) in call. These can be bitwise \texttt{OR}'d ('\texttt{|}') with other flags. \texttt O_CREAT creates file if it doesn't exist. \texttt O_TRUNC overwrites contents of file, O_APPEND writes at the end of file. When creating files, \texttt mode arguments can be added to specify permissions of new file.
        \\
    Warning: Every call to \texttt open() must have corresponding \texttt close() or else file descriptors will be left open (similar to memory leaks with \texttt new and \texttt delete).
        \\
    & \texttt
        %
        \\ \hline
    \texttt{} & \indenth\texttt{} --- 
        \\
    & \texttt
\end{longtabu}

\section{Common syscall errors}
\large \rm

\end{document}
